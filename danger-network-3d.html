<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Danger Network - Conflict Diffusion Molecule</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: 
                radial-gradient(ellipse at center, rgba(0, 0, 0, 0.2) 0%, rgba(0, 0, 0, 0.4) 100%),
                #000 url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 600"><rect width="800" height="600" fill="%23000"/><circle cx="150" cy="200" r="2" fill="%23ffeb3b" opacity="0.8"/><circle cx="180" cy="180" r="1.5" fill="%23ffeb3b" opacity="0.6"/><circle cx="200" cy="220" r="3" fill="%23ffc107" opacity="0.9"/><circle cx="350" cy="150" r="2.5" fill="%23ffeb3b" opacity="0.7"/><circle cx="400" cy="300" r="4" fill="%23ffc107" opacity="1"/><circle cx="420" cy="320" r="1" fill="%23ffeb3b" opacity="0.5"/><circle cx="600" cy="100" r="2" fill="%23ffeb3b" opacity="0.8"/><circle cx="650" cy="400" r="3" fill="%23ffc107" opacity="0.9"/><circle cx="300" cy="450" r="1.5" fill="%23ffeb3b" opacity="0.6"/><circle cx="100" cy="350" r="2" fill="%23ffeb3b" opacity="0.7"/><circle cx="750" cy="200" r="1" fill="%23ffeb3b" opacity="0.5"/><circle cx="500" cy="250" r="2.5" fill="%23ffc107" opacity="0.8"/></svg>') center/cover no-repeat;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .network-container {
            perspective: 3000px;
            perspective-origin: 50% 50%;
            width: 800px;
            height: 600px;
            position: relative;
            z-index: 2;
        }

        .network-3d {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(25deg) rotateY(-15deg) rotateZ(5deg);
            animation: networkBreathing 8s ease-in-out infinite;
        }

        /* Network nodes based on dangerShape.png */
        .network-node {
            position: absolute;
            border-radius: 50%;
            transform-style: preserve-3d;
            transition: all 1s ease-in-out;
            border: 2px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* Node intensity levels with enhanced 3D effects and wave animation */
        .node-light {
            width: 16px;
            height: 16px;
            background: radial-gradient(circle at 30% 30%, rgba(254, 202, 202, 0.9), rgba(252, 165, 165, 0.8));
            border-color: rgba(248, 113, 113, 0.6);
            box-shadow: 
                0 4px 12px rgba(252, 165, 165, 0.4),
                0 0 20px rgba(252, 165, 165, 0.2);
        }

        .node-medium {
            width: 22px;
            height: 22px;
            background: radial-gradient(circle at 30% 30%, rgba(252, 165, 165, 0.95), rgba(248, 113, 113, 0.9));
            border-color: rgba(239, 68, 68, 0.8);
            box-shadow: 
                0 6px 16px rgba(248, 113, 113, 0.5),
                0 0 25px rgba(248, 113, 113, 0.3);
        }

        .node-dark {
            width: 28px;
            height: 28px;
            background: radial-gradient(circle at 30% 30%, rgba(248, 113, 113, 0.95), rgba(220, 38, 38, 0.9));
            border-color: rgba(153, 27, 27, 1);
            box-shadow: 
                0 8px 20px rgba(220, 38, 38, 0.6),
                0 0 30px rgba(220, 38, 38, 0.4);
        }

        .node-very-dark {
            width: 32px;
            height: 32px;
            background: radial-gradient(circle at 30% 30%, rgba(220, 38, 38, 0.98), rgba(153, 27, 27, 0.95));
            border-color: rgba(127, 29, 29, 1);
            box-shadow: 
                0 10px 25px rgba(153, 27, 27, 0.7),
                0 0 40px rgba(153, 27, 27, 0.5),
                0 0 60px rgba(153, 27, 27, 0.3);
        }

        /* Wave activation states */
        .node-wave-active {
            animation: diffusionWave 2s ease-out infinite;
        }

        .node-wave-pending {
            opacity: 0.4;
            transform: scale(0.8);
            transition: all 0.5s ease-out;
        }

        /* Network edges with energy flow */
        .network-edge {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, 
                rgba(156, 163, 175, 0.3) 0%,
                rgba(156, 163, 175, 0.6) 50%,
                rgba(156, 163, 175, 0.3) 100%);
            transform-origin: 0 50%;
            transition: all 1s ease-in-out;
            border-radius: 1px;
            overflow: hidden;
        }

        .edge-active {
            background: linear-gradient(90deg, 
                rgba(220, 38, 38, 0.2) 0%,
                rgba(220, 38, 38, 0.8) 50%,
                rgba(220, 38, 38, 0.2) 100%);
            height: 3px;
            box-shadow: 
                0 0 8px rgba(220, 38, 38, 0.4),
                0 0 16px rgba(220, 38, 38, 0.2);
            animation: energyFlow 2s ease-in-out infinite;
        }

        .edge-active::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%,
                rgba(255, 255, 255, 0.6) 50%,
                transparent 100%);
            animation: energyPulse 3s ease-in-out infinite;
        }

        /* Unfolding animation */
        .unfolding {
            animation: unfoldNode 2s ease-out forwards;
        }

        @keyframes networkBreathing {
            0%, 100% { 
                transform: rotateX(25deg) rotateY(-15deg) rotateZ(5deg) scale(1);
            }
            50% { 
                transform: rotateX(25deg) rotateY(-15deg) rotateZ(5deg) scale(1.05);
            }
        }

        @keyframes diffusionWave {
            0% { 
                transform: scale(0.8) translateZ(var(--node-z, 0px));
                opacity: 0.3;
                box-shadow: 
                    0 0 10px rgba(220, 38, 38, 0.3),
                    0 0 20px rgba(220, 38, 38, 0.1);
            }
            25% {
                transform: scale(1.2) translateZ(var(--node-z, 0px));
                opacity: 1;
                box-shadow: 
                    0 0 30px rgba(220, 38, 38, 0.8),
                    0 0 50px rgba(220, 38, 38, 0.4),
                    0 0 80px rgba(220, 38, 38, 0.2);
            }
            50% { 
                transform: scale(1) translateZ(var(--node-z, 0px));
                opacity: 1;
                box-shadow: 
                    0 0 25px rgba(220, 38, 38, 0.6),
                    0 0 40px rgba(220, 38, 38, 0.3);
            }
            75% {
                transform: scale(1.1) translateZ(var(--node-z, 0px));
                opacity: 0.9;
                box-shadow: 
                    0 0 20px rgba(220, 38, 38, 0.4),
                    0 0 35px rgba(220, 38, 38, 0.2);
            }
            100% { 
                transform: scale(1) translateZ(var(--node-z, 0px));
                opacity: 0.8;
                box-shadow: 
                    0 0 15px rgba(220, 38, 38, 0.3),
                    0 0 25px rgba(220, 38, 38, 0.1);
            }
        }

        @keyframes energyFlow {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        @keyframes energyPulse {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        @keyframes unfoldNode {
            0% {
                transform: scale(0) translateZ(-100px);
                opacity: 0;
            }
            60% {
                opacity: 0.7;
            }
            100% {
                transform: scale(1) translateZ(var(--target-z, 0px));
                opacity: 1;
            }
        }

        /* Controls */
        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-radius: 25px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            z-index: 3;
        }

        .control-button {
            background: rgba(220, 38, 38, 0.9);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.85rem;
            margin: 0 5px;
            transition: all 0.2s;
            font-weight: 500;
        }

        .control-button:hover {
            background: rgba(153, 27, 27, 1);
            transform: translateY(-1px);
        }

        .time-display {
            color: #6b7280;
            font-size: 0.8rem;
            margin-bottom: 10px;
            font-family: 'Monaco', monospace;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="network-container">
        <div class="network-3d" id="network">
            <!-- Nodes and edges will be generated by JavaScript -->
        </div>
    </div>

    <div class="controls">
        <div class="time-display" id="timeDisplay">Network Evolution: t = 0</div>
        <button class="control-button" onclick="pauseAnimation()">Pause</button>
        <button class="control-button" onclick="resumeAnimation()">Resume</button>
        <button class="control-button" onclick="unfoldNetwork()">Unfold</button>
        <button class="control-button" onclick="resetNetwork()">Reset</button>
    </div>

    <script>
        // Network structure with balanced Z-depth and clean wave propagation
        const networkNodes = [
            // Main cluster (center-left) - reasonable depth variations
            { id: 'n1', x: 200, y: 150, z: 0, intensity: 'very-dark', time: 0, waveDelay: 0 },
            { id: 'n2', x: 180, y: 120, z: 150, intensity: 'dark', time: 1, waveDelay: 0.5 },
            { id: 'n3', x: 220, y: 130, z: -100, intensity: 'medium', time: 1, waveDelay: 0.7 },
            { id: 'n4', x: 160, y: 180, z: 200, intensity: 'medium', time: 2, waveDelay: 1.0 },
            { id: 'n5', x: 240, y: 170, z: -150, intensity: 'light', time: 2, waveDelay: 1.2 },
            { id: 'n6', x: 140, y: 200, z: 250, intensity: 'light', time: 3, waveDelay: 1.5 },
            { id: 'n7', x: 120, y: 160, z: 180, intensity: 'medium', time: 3, waveDelay: 1.3 },
            
            // Secondary cluster (right side) - background layer
            { id: 'n8', x: 350, y: 200, z: -200, intensity: 'dark', time: 2, waveDelay: 1.8 },
            { id: 'n9', x: 370, y: 180, z: -250, intensity: 'medium', time: 3, waveDelay: 2.0 },
            { id: 'n10', x: 390, y: 220, z: -300, intensity: 'light', time: 4, waveDelay: 2.3 },
            { id: 'n11', x: 330, y: 240, z: -120, intensity: 'light', time: 4, waveDelay: 2.1 },
            { id: 'n12', x: 410, y: 200, z: -350, intensity: 'light', time: 5, waveDelay: 2.5 },
            
            // Bottom branch - forward projection
            { id: 'n13', x: 150, y: 300, z: 300, intensity: 'medium', time: 4, waveDelay: 1.6 },
            { id: 'n14', x: 130, y: 320, z: 350, intensity: 'light', time: 5, waveDelay: 2.2 },
            { id: 'n15', x: 110, y: 340, z: 400, intensity: 'light', time: 6, waveDelay: 2.6 },
            { id: 'n16', x: 170, y: 330, z: 280, intensity: 'medium', time: 5, waveDelay: 2.0 },
            { id: 'n17', x: 190, y: 350, z: 220, intensity: 'dark', time: 6, waveDelay: 2.3 },
            
            // Top isolated branch - good depth
            { id: 'n18', x: 300, y: 100, z: 450, intensity: 'light', time: 6, waveDelay: 1.4 },
            { id: 'n19', x: 320, y: 80, z: 500, intensity: 'medium', time: 7, waveDelay: 1.7 },
            { id: 'n20', x: 280, y: 120, z: 420, intensity: 'light', time: 7, waveDelay: 1.6 },
            
            // Far bottom nodes - mixed depths
            { id: 'n21', x: 180, y: 400, z: 100, intensity: 'medium', time: 7, waveDelay: 2.8 },
            { id: 'n22', x: 160, y: 420, z: 150, intensity: 'light', time: 8, waveDelay: 3.0 },
            { id: 'n23', x: 140, y: 450, z: 200, intensity: 'light', time: 9, waveDelay: 3.2 }
        ];

        // Network connections based on the image structure
        const networkEdges = [
            // Main cluster connections
            { from: 'n1', to: 'n2' }, { from: 'n1', to: 'n3' }, { from: 'n1', to: 'n4' },
            { from: 'n2', to: 'n7' }, { from: 'n4', to: 'n6' }, { from: 'n4', to: 'n13' },
            { from: 'n3', to: 'n5' }, { from: 'n5', to: 'n8' },
            
            // Secondary cluster
            { from: 'n8', to: 'n9' }, { from: 'n8', to: 'n11' }, { from: 'n9', to: 'n10' },
            { from: 'n9', to: 'n12' }, { from: 'n10', to: 'n12' },
            
            // Bottom branch
            { from: 'n13', to: 'n14' }, { from: 'n13', to: 'n16' }, { from: 'n14', to: 'n15' },
            { from: 'n16', to: 'n17' }, { from: 'n17', to: 'n21' }, { from: 'n21', to: 'n22' },
            { from: 'n22', to: 'n23' },
            
            // Top branch
            { from: 'n3', to: 'n18' }, { from: 'n18', to: 'n19' }, { from: 'n18', to: 'n20' },
            
            // Cross connections
            { from: 'n6', to: 'n13' }, { from: 'n11', to: 'n16' }
        ];

        let currentTime = 0;
        let isUnfolding = false;
        let rotationPaused = false;

        function createNetwork() {
            const network = document.getElementById('network');
            network.innerHTML = '';

            // Create nodes with wave-based diffusion
            networkNodes.forEach(node => {
                const nodeElement = document.createElement('div');
                nodeElement.className = `network-node node-${node.intensity}`;
                nodeElement.id = node.id;
                
                // Get actual node dimensions for proper centering
                const nodeSize = node.intensity === 'very-dark' ? 32 : 
                               node.intensity === 'dark' ? 28 : 
                               node.intensity === 'medium' ? 22 : 16;
                
                // Position node with proper centering
                nodeElement.style.left = `${node.x - nodeSize / 2}px`;
                nodeElement.style.top = `${node.y - nodeSize / 2}px`;
                nodeElement.style.transform = `translateZ(${node.z}px)`;
                nodeElement.style.setProperty('--node-z', `${node.z}px`);
                
                // Apply clean wave-based activation
                const waveTime = (currentTime * 1.5) % 4; // Slower, cleaner wave
                const nodeWaveTime = node.waveDelay % 4;
                
                if (node.time <= currentTime) {
                    if (Math.abs(waveTime - nodeWaveTime) < 0.4 || 
                        Math.abs(waveTime - nodeWaveTime + 4) < 0.4 || 
                        Math.abs(waveTime - nodeWaveTime - 4) < 0.4) {
                        nodeElement.classList.add('node-wave-active');
                    } else {
                        nodeElement.style.opacity = '0.9';
                    }
                    
                    if (isUnfolding) {
                        nodeElement.classList.add('unfolding');
                        nodeElement.style.setProperty('--target-z', `${node.z}px`);
                    }
                } else {
                    nodeElement.classList.add('node-wave-pending');
                }
                
                network.appendChild(nodeElement);
            });

            // Create edges with simple, accurate connections
            networkEdges.forEach(edge => {
                const fromNode = networkNodes.find(n => n.id === edge.from);
                const toNode = networkNodes.find(n => n.id === edge.to);
                
                if (fromNode && toNode) {
                    const edgeElement = document.createElement('div');
                    edgeElement.className = 'network-edge';
                    
                    // Simple center-to-center connection
                    const dx = toNode.x - fromNode.x;
                    const dy = toNode.y - fromNode.y;
                    const dz = toNode.z - fromNode.z;
                    const length = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    // Position edge from fromNode center
                    edgeElement.style.left = `${fromNode.x}px`;
                    edgeElement.style.top = `${fromNode.y}px`;
                    edgeElement.style.width = `${length}px`;
                    edgeElement.style.height = '2px';
                    edgeElement.style.transform = `translateZ(${fromNode.z + dz/2}px) rotate(${angle}deg)`;
                    edgeElement.style.transformOrigin = '0 50%';
                    
                    // Show/hide based on time
                    if (fromNode.time <= currentTime && toNode.time <= currentTime) {
                        edgeElement.style.opacity = '1';
                        edgeElement.classList.add('edge-active');
                    } else {
                        edgeElement.style.opacity = '0.3';
                    }
                    
                    network.appendChild(edgeElement);
                }
            });
        }

        function updateTimeDisplay() {
            document.getElementById('timeDisplay').textContent = `Network Evolution: t = ${Math.floor(currentTime)}`;
        }

        function unfoldNetwork() {
            isUnfolding = true;
            currentTime = Math.min(10, currentTime + 2);
            createNetwork();
            updateTimeDisplay();
            
            // Reset unfolding flag after animation
            setTimeout(() => {
                isUnfolding = false;
            }, 2000);
        }

        function pauseAnimation() {
            document.querySelector('.network-3d').style.animationPlayState = 'paused';
            document.querySelectorAll('.network-node').forEach(node => {
                node.style.animationPlayState = 'paused';
            });
            document.querySelectorAll('.edge-active').forEach(edge => {
                edge.style.animationPlayState = 'paused';
            });
        }

        function resumeAnimation() {
            document.querySelector('.network-3d').style.animationPlayState = 'running';
            document.querySelectorAll('.network-node').forEach(node => {
                node.style.animationPlayState = 'running';
            });
            document.querySelectorAll('.edge-active').forEach(edge => {
                edge.style.animationPlayState = 'running';
            });
        }

        function resetNetwork() {
            currentTime = 0;
            isUnfolding = false;
            createNetwork();
            updateTimeDisplay();
            resumeRotation();
        }

        // Auto-evolution (balanced speed)
        setInterval(() => {
            if (!isUnfolding && currentTime < 10) {
                currentTime += 0.1;
                createNetwork();
                updateTimeDisplay();
            }
        }, 400);

        // Mouse interaction
        let isDragging = false;
        let startX, startY;
        let rotationX = 15, rotationY = 0;

        document.addEventListener('mousedown', (e) => {
            if (e.target.closest('.network-container')) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                pauseRotation();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                rotationY += deltaX * 0.5;
                rotationX -= deltaY * 0.5;
                rotationX = Math.max(-60, Math.min(60, rotationX));
                
                const network = document.querySelector('.network-3d');
                network.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;
                
                startX = e.clientX;
                startY = e.clientY;
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                setTimeout(resumeAnimation, 1000);
            }
        });

        // Initialize
        createNetwork();
        updateTimeDisplay();
    </script>
</body>
</html>