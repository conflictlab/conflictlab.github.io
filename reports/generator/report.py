# -*- coding: utf-8 -*-
"""
Created on Wed Feb 26 22:43:51 2025

@author: thoma
"""

from shape import Shape,finder
import matplotlib as _mpl_backend
_mpl_backend.use('Agg')
import matplotlib.pyplot as plt
import json
from matplotlib.patches import Polygon as MplPolygon
import pandas as pd
import pickle 
import numpy as np
import seaborn as sns
import matplotlib as mpl
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score, classification_report
import matplotlib.dates as mdates
dtw = None
ed = None
from matplotlib.ticker import ScalarFormatter
import requests
from sklearn.metrics import mean_squared_error
import unicodedata

# Centralized paths relative to this script
import os
GEN_DIR = os.path.dirname(__file__)
ROOT_DIR = os.path.abspath(os.path.join(GEN_DIR, '..'))

# Overleaf output paths
OUTPUT_DIR = os.path.join(ROOT_DIR, 'overleaf', 'Fig_2025')
TABLE_DIR = os.path.join(ROOT_DIR, 'overleaf', 'tables')
META_PATH = os.path.join(ROOT_DIR, 'overleaf', 'meta.tex')

os.makedirs(OUTPUT_DIR, exist_ok=True)
os.makedirs(TABLE_DIR, exist_ok=True)

# Optional skip flags for external benchmarks (default: skip)
SKIP_CF = os.environ.get('SKIP_CF', '1').lower() in ('1','true','yes')
SKIP_VIEWS = os.environ.get('SKIP_VIEWS', '1').lower() in ('1','true','yes')

def savefig_stem(stem, exts=(".png",)):
    for ext in exts:
        path = os.path.join(OUTPUT_DIR, f"{stem}{ext}")
        plt.savefig(path, dpi=200, bbox_inches='tight')
    plt.close()

def write_meta_tex(subtitle, observed_range, predicted_range, report_date, report_status):
    try:
        with open(META_PATH, 'w') as f:
            f.write('% Auto-generated by report.py\n')
            f.write(f"\\newcommand{{\\ReportSubtitle}}{{{subtitle}}}\n")
            f.write(f"\\newcommand{{\\ObservedPeriod}}{{{observed_range}}}\n")
            f.write(f"\\newcommand{{\\PredictedPeriod}}{{{predicted_range}}}\n")
            f.write(f"\\newcommand{{\\ReportDate}}{{{report_date}}}\n")
            f.write(f"\\newcommand{{\\ReportStatus}}{{{report_status}}}\n")
    except Exception as e:
        print('Warning: failed to write meta.tex:', e)


# --- Helpers to avoid GeoPandas/Fiona ---
def load_world_features(path):
    with open(path, 'r') as f:
        gj = json.load(f)
    feats = []
    for ft in gj.get('features', []):
        name = ft.get('properties', {}).get('name')
        geom = ft.get('geometry', {})
        gtype = geom.get('type')
        coords = geom.get('coordinates', [])
        polys = []
        if gtype == 'Polygon':
            if coords:
                polys.append(coords[0])  # outer ring
        elif gtype == 'MultiPolygon':
            for poly in coords:
                if poly:
                    polys.append(poly[0])  # outer ring
        feats.append({'name': name, 'polygons': polys})
    return feats

def draw_map_numeric(features, values_by_name, cmap, norm, outfile, hatch_missing=True):
    fig, ax = plt.subplots(1, 1, figsize=(30, 15))
    for ft in features:
        name = ft['name']
        val = None if values_by_name is None else values_by_name.get(name)
        # treat invalid or nonpositive in log scales as missing
        is_missing = (val is None) or (hasattr(norm, 'log') and (val is None or val <= 0))
        if is_missing:
            for ring in ft['polygons']:
                poly = MplPolygon(ring, closed=True, facecolor='white', edgecolor='dimgrey', linewidth=0.3,
                                  hatch='///' if hatch_missing else None)
                ax.add_patch(poly)
        else:
            color = cmap(norm(val))
            for ring in ft['polygons']:
                poly = MplPolygon(ring, closed=True, facecolor=color, edgecolor='black', linewidth=0.2)
                ax.add_patch(poly)
    ax.set_xlim(-180, 180)
    ax.set_ylim(-90, 90)
    ax.set_xticks([]); ax.set_yticks([])
    ax.set_xticklabels([]); ax.set_yticklabels([])
    plt.box(False)
    sm = mpl.cm.ScalarMappable(cmap=cmap, norm=norm)
    sm.set_array([])
    cbar = fig.colorbar(sm, ax=ax, orientation='vertical', fraction=0.015, pad=0.01, shrink=0.5)
    cbar.ax.tick_params(labelsize=18)
    if outfile:
        plt.savefig(outfile, bbox_inches='tight')
    plt.show()

def draw_map_categorical(features, colors_by_name, outfile):
    fig, ax = plt.subplots(1, 1, figsize=(30, 15))
    for ft in features:
        name = ft['name']
        col = (colors_by_name or {}).get(name)
        if col is None:
            for ring in ft['polygons']:
                poly = MplPolygon(ring, closed=True, facecolor='white', edgecolor='dimgrey', linewidth=0.3, hatch='///')
                ax.add_patch(poly)
        else:
            for ring in ft['polygons']:
                poly = MplPolygon(ring, closed=True, facecolor=col, edgecolor='black', linewidth=0.2)
                ax.add_patch(poly)
    ax.set_xlim(-180, 180)
    ax.set_ylim(-90, 90)
    ax.set_xticks([]); ax.set_yticks([])
    ax.set_xticklabels([]); ax.set_yticklabels([])
    plt.box(False)
    if outfile:
        plt.savefig(outfile, bbox_inches='tight')
    plt.show()

world_features = load_world_features(os.path.join(GEN_DIR, 'world_plot.geojson'))
world_names = set(ft['name'] for ft in world_features)
pred_df=pd.read_csv('Pred_df.csv',parse_dates=True,index_col=(0))
missing_columns = world_names - set(pred_df.columns)
    
# No need to unpickle scenarios; rely on Pred_df.csv
missing_columns.discard('Dominican Rep.')
hist_df=pd.read_csv('Hist.csv',parse_dates=True,index_col=(0))
# Ensure added placeholder columns match the number of rows in Hist.csv
if missing_columns:
    hist_df = hist_df.assign(**{col: [0] * len(hist_df) for col in missing_columns})

# Prefer archived 6-month predictions that align to a past cycle if provided
ARCHIVE_PRED_FILE = os.environ.get('ARCHIVE_PRED_FILE')
df_true_all = pd.read_csv('Hist.csv', parse_dates=True, index_col=(0))
archive_month_title = None
if ARCHIVE_PRED_FILE and os.path.exists(ARCHIVE_PRED_FILE):
    try:
        df_pred_full = pd.read_csv(ARCHIVE_PRED_FILE, parse_dates=True, index_col=(0))
        # Try to parse archive month for cover date
        try:
            base = os.path.basename(ARCHIVE_PRED_FILE)
            ym = os.path.splitext(base)[0]  # YYYY-MM
            y, m = ym.split('-')
            m = int(m); y = int(y)
            month_names = ['January','February','March','April','May','June','July','August','September','October','November','December']
            archive_month_title = f"{month_names[m-1]} {y}"
        except Exception:
            archive_month_title = None
        # Align truth to the archive's months (clip to available for comparison-only plots)
        idx = pd.to_datetime(df_pred_full.index)
        df_true_all.index = pd.to_datetime(df_true_all.index)
        common_idx = df_true_all.index.intersection(idx)
        if len(common_idx) < len(idx):
            print(f"Warning: clipping months: {len(idx)-len(common_idx)} not present in Hist.csv")
        df_pred_overlap = df_pred_full.loc[common_idx] if len(common_idx) else pd.DataFrame(index=common_idx)
        df_true = df_true_all.loc[common_idx]
        # Keep full predictions for forecast-only plots
        df_pred = df_pred_full
    except Exception as e:
        print(f'Failed to load archived predictions {ARCHIVE_PRED_FILE}:', e)
        df_pred = pred_df.copy()
        df_true = pd.read_csv('Hist_true.csv',parse_dates=True,index_col=(0)).iloc[-6:,:]
        df_pred_overlap = df_pred.copy()
else:
    # Use provided Pred_df.csv (whatever the latest 6 rows are)
    df_pred = pred_df.copy()
    df_true = pd.read_csv('Hist_true.csv',parse_dates=True,index_col=(0)).iloc[-6:,:]
    df_pred_overlap = df_pred.copy()

tot = set(df_pred.columns) | set(df_true.columns)
pred_miss = tot - set(df_pred.columns)
df_pred = df_pred.assign(**{col: [0] * len(df_pred) for col in pred_miss})
true_miss = tot - set(df_true.columns)
df_true = df_true.assign(**{col: [0] * len(df_true) for col in true_miss})
df_true = df_true[df_pred.columns.tolist()]

# Ensure hist_df has all columns present in predictions/true
hist_missing = set(df_pred.columns) - set(hist_df.columns)
if hist_missing:
    hist_df = hist_df.assign(**{col: [0] * len(hist_df) for col in hist_missing})

# -- Prepare meta for LaTeX (best-effort)
def _fmt_range(idx):
    try:
        s = pd.to_datetime(idx.min())
        e = pd.to_datetime(idx.max())
        # Use LaTeX-friendly dash (no Unicode en-dash)
        return f"{s.strftime('%B %Y')}--{e.strftime('%B %Y')}"
    except Exception:
        return "(unknown)"

observed_range_str = _fmt_range(df_true.index)
predicted_range_str = _fmt_range(df_pred.index)
try:
    # Use first forecast month as report subtitle (matches site convention)
    first_idx = pd.to_datetime(df_pred.index).min()
    subtitle_str = first_idx.strftime('%B %Y')
except Exception:
    subtitle_str = ''
report_date_str = archive_month_title or subtitle_str
# Add 'Preliminary ' marker if fewer observed months than forecast months
try:
    obs_months = len(pd.to_datetime(df_true.index).unique())
except Exception:
    obs_months = 0
try:
    fc_months = len(pd.to_datetime(df_pred.index).unique())
except Exception:
    fc_months = 6
report_status = 'Preliminary ' if obs_months < fc_months else ''
write_meta_tex(subtitle_str, observed_range_str, predicted_range_str, report_date_str, report_status)

# =============================================================================
# Error Plots
# =============================================================================

pred_sums = df_pred.sum()
true_sums = df_true.sum()
pred_sums = pred_sums.rename(index={'Israel': 'Israel-Palestine'})
true_sums = true_sums.rename(index={'Israel': 'Israel-Palestine'})
differences = true_sums - pred_sums

true_sums = true_sums.sort_values(ascending=False).iloc[:30]
differences= differences[true_sums.index]
pred_sums = pred_sums[true_sums.index]
differences = differences.fillna(0)


plt.figure(figsize=(12, 10))
sns.barplot(x=pred_sums.values, y=pred_sums.index, color='darkgrey')
for i, (pred, diff) in enumerate(zip(pred_sums, differences)):
    if i == 0 : 
        plt.barh(pred_sums.index[i], diff, left=pred, color='darkred', alpha=0.8,label='Underprediction')
    elif i ==3:
        plt.barh(pred_sums.index[i], diff, left=pred, color='darkgrey', alpha=1, hatch='////',edgecolor='darkblue',label='Overprediction')
    else:
        if diff > 0:
            plt.barh(pred_sums.index[i], diff, left=pred, color='darkred', alpha=0.8)
        else:
            plt.barh(pred_sums.index[i], diff, left=pred, color='darkgrey', alpha=1, hatch='////',edgecolor='darkblue')
plt.xlabel('Sum Value', fontsize=20)
plt.xticks(fontsize=18)
plt.yticks(fontsize=18)
plt.xscale('log')
plt.gca().xaxis.set_major_formatter(ScalarFormatter())
plt.gca().xaxis.get_major_formatter().set_scientific(False)
plt.gca().spines['top'].set_visible(False)
plt.gca().spines['right'].set_visible(False)
plt.legend(fontsize=20)
plt.tight_layout()
savefig_stem('Fore_all', exts=(".png",))

pred_sums = df_pred.sum()
true_sums = df_true.sum()
differences = ((true_sums - pred_sums) / true_sums )*100
differences = differences[true_sums>15]

vals = differences.dropna().to_dict()
draw_map_numeric(world_features, vals, plt.get_cmap('coolwarm'), mpl.colors.Normalize(vmin=-100, vmax=100), os.path.join(OUTPUT_DIR, 'Fore_map.png'), hatch_missing=True)


# Predicted map should always reflect full 6-month forecast values
try:
    vals = df_pred.sum().dropna().to_dict()
    draw_map_numeric(world_features, vals, plt.get_cmap('Reds'), mpl.colors.LogNorm(vmin=1, vmax=10000), os.path.join(OUTPUT_DIR, 'pred_map.pdf'), hatch_missing=False)
except Exception:
    # fallback to overlap if needed
    vals = df_pred_overlap.sum().dropna().to_dict()
    draw_map_numeric(world_features, vals, plt.get_cmap('Reds'), mpl.colors.LogNorm(vmin=1, vmax=10000), os.path.join(OUTPUT_DIR, 'pred_map.pdf'), hatch_missing=False)


if len(df_true) == 0:
    # No truth available: draw fully hatched map
    draw_map_numeric(world_features, None, plt.get_cmap('Reds'), mpl.colors.LogNorm(vmin=1, vmax=10000), os.path.join(OUTPUT_DIR, 'true_map.pdf'), hatch_missing=True)
else:
    vals = true_sums.dropna().to_dict()
    draw_map_numeric(world_features, vals, plt.get_cmap('Reds'), mpl.colors.LogNorm(vmin=1, vmax=10000), os.path.join(OUTPUT_DIR, 'true_map.pdf'), hatch_missing=False)


# =============================================================================
# Increse/Decrease Plots
# =============================================================================

def classify_i_d(pred,obs):
    sum_p=pred.sum()
    sum_o=obs.sum()
    if sum_o == 0 : 
        sum_o=1
    if sum_p<(0.8*sum_o):
        out = 'Decrease'
    elif (sum_p>(0.8*sum_o)) & (sum_p<(1.2*sum_o)):
        out = 'Stable'
    else:
        out = 'Increase'
    if sum_o>14:
        return out,sum_p/sum_o
    else:
        return out,float('NaN')

i_d=[]
ratio_d=[]
for i,j in enumerate(df_true.columns):
    true_d,ratio_dt = classify_i_d(df_true.loc[:,j],hist_df.loc[:,j].iloc[-6:])
    pred_d,ratio_dp = classify_i_d(df_pred.loc[:,j],hist_df.loc[:,j].iloc[-6:])
    i_d.append([true_d,pred_d])
    ratio_d.append([ratio_dt,ratio_dp])

i_d = pd.DataFrame(i_d)
i_d.columns=['Observed','Prediction']
i_d.index = df_true.columns

ratio_d = pd.DataFrame(ratio_d)
ratio_d.columns=['Observed','Prediction']
ratio_d.index = df_true.columns

observed = i_d['Observed'].values
predicted = i_d['Prediction'].values
conf_matrix = confusion_matrix(observed, predicted,labels=['Decrease','Stable','Increase'])
accuracy = accuracy_score(observed, predicted)
precision = precision_score(observed, predicted, labels=['Decrease', 'Stable', 'Increase'], average='weighted')
recall = recall_score(observed, predicted, labels=['Decrease', 'Stable', 'Increase'], average='weighted')
f1 = f1_score(observed, predicted, labels=['Decrease', 'Stable', 'Increase'], average='weighted')
report = classification_report(observed, predicted, labels=['Decrease', 'Stable', 'Increase'], target_names=['Decrease', 'Stable', 'Increase'])


print("Confusion Matrix:")
print(conf_matrix)
print("\nAccuracy:", accuracy)
print("\nPrecision for each class:", precision)
print("\nRecall for each class:", recall)
print("\nF1 Score for each class:", f1)
print("\nClassification Report:\n", report)


plt.figure(figsize=(10,8))
sns.heatmap(conf_matrix/np.sum(conf_matrix), annot=True, fmt='.2%', cmap='Reds',cbar=False,
            xticklabels=['Decrease','Stable','Increase'],yticklabels=['Decrease','Stable','Increase'])
plt.xlabel('Predicted', fontsize=20)
plt.ylabel('Observed', fontsize=20)
plt.xticks(fontsize=16)
plt.yticks(fontsize=16)
for text in plt.gca().texts:
    text.set_fontsize(20)
savefig_stem('Heatmap', exts=(".png",))


classif = []
if len(df_true) > 0:
    for i in range(len(i_d)):
        if i_d.iloc[i,0] == i_d.iloc[i,1]:
            classif.append('#018749')
        elif (i_d.iloc[i,1] == 'Stable') | (i_d.iloc[i,0] == 'Stable'):
            classif.append('#FEBE10')
        else:
            classif.append('#BA0021')
    i_d['Classif'] = classif

    colors_by = {}
    for nm, row in i_d.iterrows():
        colors_by[nm] = row['Classif']
    draw_map_categorical(world_features, colors_by, os.path.join(OUTPUT_DIR, 'classification_map.png'))
else:
    # Placeholder classification map (all hatched)
    draw_map_categorical(world_features, {}, os.path.join(OUTPUT_DIR, 'classification_map.png'))

if len(df_true) > 0:
    plt.figure(figsize=(12,12))
    sns.jointplot(data=ratio_d,x="Observed",y="Prediction",kind='reg',color='#B11B1B',
                  xlim=(-0.1, 3),             
                  ylim=(-0.1, 3),
                  marginal_kws=dict(bins=[0,0.5,1,1.5,2,2.5,3], fill=True))
    plt.plot(pd.Series(data=np.linspace(0,3000,3000)/1000,index=np.linspace(0,3000,3000)/1000),linestyle='--',alpha=0.5,color='black',label='Prefect Prediction')
    plt.show()


# =============================================================================
# Shapes (optional if dtaidistance available)
# =============================================================================
df_shape = pd.DataFrame(columns=['DTW','ED','SUM'])
try:
    from dtaidistance import dtw as _dtw, ed as _ed
    dtw, ed = _dtw, _ed
    l_dtw=[]
    l_ed=[]
    for i,j in enumerate(df_true.columns):
        tr = pd.concat([hist_df.loc[:,j].iloc[-6:],df_true.loc[:,j]],axis=0)
        if tr.max()>0:
            t1 = (df_true.loc[:,j] - tr.min()) / (tr.max()-tr.min())
            t2 = (df_pred.loc[:,j] - tr.min()) / (tr.max()-tr.min())
        else:
            t1 = df_true.loc[:,j]
            t2 = df_pred.loc[:,j]
        l_dtw.append(_dtw.distance(t1,t2))
        l_ed.append(_ed.distance(t1,t2))

    df_shape=pd.DataFrame([l_dtw,l_ed,df_true.sum().tolist()]).T
    df_shape.index=df_true.columns
    df_shape.columns=['DTW','ED','SUM']
    df_shape = df_shape.dropna()
    df_shape=df_shape[df_shape['SUM']>15]
except Exception as e:
    print('Skipping DTW/ED shape analysis:', e)

# Map of DTW distances (only if truth available)
if len(df_true) > 0 and not df_shape.empty:
    vals = df_shape['DTW'].dropna().to_dict()
    draw_map_numeric(world_features, vals, plt.get_cmap('Reds'), mpl.colors.Normalize(vmin=0, vmax=2), os.path.join(OUTPUT_DIR, 'dtw_map.png'), hatch_missing=True)

# Best-matching time series or forecast-only fallback
if len(df_true) > 0 and not df_shape.empty:
    df_shape=df_shape[df_shape['SUM']>15]
    df_shape=df_shape.sort_values(['DTW'],ascending=True)
    plt.figure(figsize=(12, 10))
    sns.barplot(x=df_shape['DTW'].values, y=df_shape['DTW'].index, palette='Reds_r')
    plt.gca().spines['top'].set_visible(False)
    plt.gca().spines['right'].set_visible(False)
    plt.show()

    num_subplots = 0
    fig, axes = plt.subplots(3, 5, figsize=(25, 12), sharey=False)
    axes = axes.flatten()
    for i in range(len(df_shape)):
        if num_subplots >= len(axes):
            break
        if (df_shape.iloc[i,0]<0.8):
            try:
                name = df_shape.index[i]
                name_title = 'Israel-Palestine' if name == 'Israel' else name
                tr = pd.concat([hist_df.loc[:,name].iloc[-6:], df_true.loc[:,name]], axis=0)
                pr = pd.concat([hist_df.loc[:,name].iloc[-1:], df_pred.loc[:,name]], axis=0)
                tr = tr.copy(); tr.index = pd.to_datetime(tr.index); tr = tr.sort_index()
                pr = pr.copy(); pr.index = pd.to_datetime(pr.index); pr = pr.sort_index()
                axes[num_subplots].plot(tr.index, tr.values, color='dimgrey', linewidth=3)
                axes[num_subplots].plot(pr.index, pr.values, color='darkred', linewidth=2)
                axes[num_subplots].spines['top'].set_visible(False)
                axes[num_subplots].spines['right'].set_visible(False)
                axes[num_subplots].set_title(name_title, fontsize=16)
                axes[num_subplots].xaxis.set_major_locator(mdates.MonthLocator(bymonthday=None, interval=3))
                axes[num_subplots].xaxis.set_major_formatter(mdates.DateFormatter('%b %y'))
                num_subplots+=1
            except Exception:
                pass
    plt.tight_layout()
    savefig_stem('dtw_best', exts=(".png",))
else:
    # Forecast-only fallback: plot top predicted countries by 6-month sums
    try:
        top = df_pred.sum().sort_values(ascending=False).index[:12]
        num_subplots = 0
        fig, axes = plt.subplots(3, 4, figsize=(20, 10), sharey=False)
        axes = axes.flatten()
        for name in top:
            if num_subplots >= len(axes):
                break
            tr = hist_df.loc[:,name].iloc[-6:]
            pr = pd.concat([hist_df.loc[:,name].iloc[-1:], df_pred.loc[:,name]], axis=0)
            tr = tr.copy(); tr.index = pd.to_datetime(tr.index); tr = tr.sort_index()
            pr = pr.copy(); pr.index = pd.to_datetime(pr.index); pr = pr.sort_index()
            axes[num_subplots].plot(tr.index, tr.values, color='dimgrey', linewidth=3)
            axes[num_subplots].plot(pr.index, pr.values, color='darkred', linewidth=2)
            axes[num_subplots].spines['top'].set_visible(False)
            axes[num_subplots].spines['right'].set_visible(False)
            axes[num_subplots].set_title(name, fontsize=16)
            axes[num_subplots].xaxis.set_major_locator(mdates.MonthLocator(bymonthday=None, interval=3))
            axes[num_subplots].xaxis.set_major_formatter(mdates.DateFormatter('%b %y'))
            num_subplots+=1
        plt.tight_layout()
        savefig_stem('dtw_best', exts=(".png",))
    except Exception as e:
        print('Skipping forecast-only dtw_best fallback:', e)


if len(df_true) > 0 and not df_shape.empty:
    num_subplots = 0
    fig, axes = plt.subplots(3, 4, figsize=(20, 10), sharey=False)
    axes = axes.flatten()
    for i in range(len(df_shape)):
        if num_subplots >= len(axes):
            break
        if (df_shape.iloc[i,0]>1):
            name = df_shape.index[i]
            tr = pd.concat([hist_df.loc[:,name].iloc[-6:], df_true.loc[:,name]], axis=0)
            pr = pd.concat([hist_df.loc[:,name].iloc[-1:], df_pred.loc[:,name]], axis=0)
            tr = tr.copy(); tr.index = pd.to_datetime(tr.index); tr = tr.sort_index()
            pr = pr.copy(); pr.index = pd.to_datetime(pr.index); pr = pr.sort_index()
            axes[num_subplots].plot(tr.index, tr.values, color='dimgrey', linewidth=3)
            axes[num_subplots].plot(pr.index, pr.values, color='darkred', linewidth=2)
            axes[num_subplots].spines['top'].set_visible(False)
            axes[num_subplots].spines['right'].set_visible(False)
            axes[num_subplots].set_title(name, fontsize=16)
            axes[num_subplots].xaxis.set_major_locator(mdates.MonthLocator(bymonthday=None, interval=3))
            axes[num_subplots].xaxis.set_major_formatter(mdates.DateFormatter('%b %y'))
            num_subplots+=1
            if num_subplots==11:
                axes[num_subplots].set_visible(False)
    plt.tight_layout()
    plt.show()


# Build offline iso3->name mapping from world geojson
try:
    with open(os.path.join(GEN_DIR, 'world_plot.geojson'), 'r') as f:
        gj = json.load(f)
    iso3_to_name = {}
    for ft in gj.get('features', []):
        props = ft.get('properties', {})
        iso = props.get('iso_a3')
        nm = props.get('name')
        if iso and nm:
            iso3_to_name[iso] = nm
    df_country_code = pd.DataFrame({'isoab': list(iso3_to_name.keys()), 'name': list(iso3_to_name.values())})
except Exception as e:
    print('Skipping CF iso mapping build due to input error:', e)
    df_country_code = pd.DataFrame(columns=['isoab','name'])

if (not SKIP_CF) and (not df_country_code.empty):
    # =============================================================================
    # Part 1 : August - October
    # =============================================================================

    df_cf = pd.read_csv('conf_fore.csv')
    df_cf = df_cf[df_cf['period']==202407]
    df_cf = df_cf.join(df_country_code.set_index('isoab'), on='isocode')
    df_cf = df_cf[['name','int_lnbest_03_all']]
    df_cf['int_lnbest_03_all'] = np.exp(df_cf['int_lnbest_03_all'])-1
    df_cf.dropna(inplace=True)

    df_cf['name'] = df_cf['name'].replace({'Bosnia and Herzegovina':'Bosnia and Herz.','Central African Republic':'Central African Rep.',
                           'Congo, DRC':'Dem. Rep. Congo','Cote d\'Ivoire':'Côte d\'Ivoire','Swaziland':'eSwatini','South Sudan':'S. Sudan',
                           'United States':'United States of America','Solomon Is.':'Solomon Islands','The Gambia':'Gambia'})

    df_pred_3 = df_pred.iloc[:3,:].sum().reset_index()
    df_true_3 = df_true.iloc[:3,:].sum().reset_index()
    df_cf = df_cf[df_cf['name'].isin(df_true_3['index'].tolist())]
    df_cf.columns = df_true_3.columns

    df_missing = df_true_3[~df_true_3['index'].isin(df_cf['index'])]
    df_missing.loc[:,0] = np.nan
    df_combined = pd.concat([df_cf, df_missing], ignore_index=True)

    ratio_3 = []
    for i in df_true_3.iloc[:,0]:
        if df_true_3[df_true_3.iloc[:,0]==i].iloc[0,1] > 15 and not df_cf[df_cf.iloc[:,0]==i].empty:
            true=df_true_3[df_true_3.iloc[:,0]==i].iloc[0,1]
            cf = df_cf[df_cf.iloc[:,0]==i].iloc[0,1]
            pred = df_pred_3[df_pred_3.iloc[:,0]==i].iloc[0,1]
            ratio_3.append([i,np.log(abs(cf-true)/abs(pred-true))])
    if len(ratio_3):
        ratio_3 = pd.DataFrame(ratio_3)
        differences=ratio_3.iloc[:,1]
        differences.index = ratio_3.iloc[:,0]
        differences = differences.rename(index={'Israel': 'Israel-Palestine'})

        norm = plt.Normalize(-2, 2)
        differences = differences.sort_values(ascending=True)
        colors = plt.cm.coolwarm(norm(differences.values))
        plt.figure(figsize=(12, 14))
        sns.barplot(x=differences.values, y=differences.index, palette=colors)
        plt.xlabel('Log Ratio of MAE - August/October', fontsize=20)
        plt.xticks(fontsize=18)
        plt.yticks(fontsize=18)
        plt.gca().xaxis.set_major_formatter(ScalarFormatter())
        plt.gca().xaxis.get_major_formatter().set_scientific(False)
        plt.gca().spines['top'].set_visible(False)
        plt.gca().spines['right'].set_visible(False)
        plt.tight_layout()
        plt.xlim(-3.5,3.5)
        plt.axvline(0,color='black')
        plt.grid(axis='y',alpha=0.5)
        plt.ylabel('')
        savefig_stem('ConflictForecast_1', exts=(".png",))

        print(len(differences[differences>0])/len(differences))
    else:
        print('Skipping CF part 1 comparisons (no matched rows)')

# =============================================================================
# Part 2 : May - July
# =============================================================================

    # Part 2 : May - July
    df_cf = pd.read_csv('conf_fore_part2.csv')
    df_cf = df_cf[df_cf['period']==202410]
    df_cf = df_cf.join(df_country_code.set_index('isoab'), on='isocode')
    df_cf = df_cf[['name','int_lnbest_03_all']]
    df_cf['int_lnbest_03_all'] = np.exp(df_cf['int_lnbest_03_all'])-1
    df_cf.dropna(inplace=True)

    df_cf['name'] = df_cf['name'].replace({'Bosnia and Herzegovina':'Bosnia and Herz.','Central African Republic':'Central African Rep.',
                           'Congo, DRC':'Dem. Rep. Congo','Cote d\'Ivoire':'Côte d\'Ivoire','Swaziland':'eSwatini','South Sudan':'S. Sudan',
                           'United States':'United States of America','Solomon Is.':'Solomon Islands','The Gambia':'Gambia'})

    df_pred_3 = df_pred.iloc[3:,:].sum().reset_index()
    df_true_3 = df_true.iloc[3:,:].sum().reset_index()
    df_cf = df_cf[df_cf['name'].isin(df_true_3['index'].tolist())]
    df_cf.columns = df_true_3.columns

    df_missing = df_true_3[~df_true_3['index'].isin(df_cf['index'])]
    df_missing.loc[:,0] = np.nan
    df_combined = pd.concat([df_cf, df_missing], ignore_index=True)

    ratio_3 = []
    for i in df_true_3.iloc[:,0]:
        if df_true_3[df_true_3.iloc[:,0]==i].iloc[0,1] > 15 and not df_cf[df_cf.iloc[:,0]==i].empty:
            true=df_true_3[df_true_3.iloc[:,0]==i].iloc[0,1]
            cf = df_cf[df_cf.iloc[:,0]==i].iloc[0,1]
            pred = df_pred_3[df_pred_3.iloc[:,0]==i].iloc[0,1]
            ratio_3.append([i,np.log(abs(cf-true)/abs(pred-true))])
    if len(ratio_3):
        ratio_3 = pd.DataFrame(ratio_3)
        differences=ratio_3.iloc[:,1]
        differences.index = ratio_3.iloc[:,0]
        differences = differences.rename(index={'Israel': 'Israel-Palestine'})
        norm = plt.Normalize(-2, 2)
        differences = differences.sort_values(ascending=True)
        colors = plt.cm.coolwarm(norm(differences.values))
        plt.figure(figsize=(12, 14))
        sns.barplot(x=differences.values, y=differences.index, palette=colors)
        plt.xlabel('Log Ratio of MAE - May/July', fontsize=20)
        plt.xticks(fontsize=18)
        plt.yticks(fontsize=18)
        plt.gca().xaxis.set_major_formatter(ScalarFormatter())
        plt.gca().xaxis.get_major_formatter().set_scientific(False)
        plt.gca().spines['top'].set_visible(False)
        plt.gca().spines['right'].set_visible(False)
        plt.tight_layout()
        plt.xlim(-3.5,3.5)
        plt.axvline(0,color='black')
        plt.grid(axis='y',alpha=0.5)
        plt.ylabel('')
        savefig_stem('ConflictForecast_2', exts=(".png",))

        print(len(differences[differences>0])/len(differences))
    else:
        print('Skipping CF part 2 comparisons (no matched rows)')
else:
    print('Skipping CF comparisons (offline / no iso mapping)')
if (len(df_true) > 0) and (not SKIP_VIEWS):
    try:
        # Lightweight VIEWS benchmark via API only (no large downloads)
        df_list_preds={f"fatalities002_2024_07_t01/cm?page={i}":i for i in range(1,8)}
        df_all=pd.DataFrame()
        for i in range(len(df_list_preds)):
            response = requests.get(f'https://api.viewsforecasting.org/{list(df_list_preds.keys())[i]}', timeout=10)
            response.raise_for_status()
            json_data = response.json()
            df=pd.DataFrame(json_data.get("data", []))
            if df.empty:
                continue
            df=df[['name','month_id','month','main_mean']]
            df_all = pd.concat([df_all, df])
            df_all=df_all.reset_index(drop=True)
        if not df_all.empty:
            cc_sort=df_all.name.unique(); cc_sort.sort()
            df_preds_test_1 = df_all.pivot(index="month_id",columns='name', values='main_mean')
            df_preds_test_1 = df_preds_test_1.iloc[:6,:]
            df_preds_test_1 = df_preds_test_1.rename(columns={'Myanmar':'Myanmar (Burma)','Central African Republic':'Central African Republic',
                                    'Congo, DRC':'DR Congo (Zaire)',"Cote d'Ivoire":'Ivory Coast','Swaziland':'Kingdom of eSwatini (Swaziland)','Vietnam':'Vietnam (North Vietnam)',
                                    'United States':'United States of America','Yemen':'Yemen (North Yemen)','Russia':'Russia (Soviet Union)'})
            df_views = df_preds_test_1.copy()
            df_views.reset_index(drop=True,inplace=True)

            common = df_views.columns.intersection(df_pred.columns)
            if len(common) > 0:
                ratio_mse=[]
                for i in common:
                    ratio_mse.append(np.log((mean_squared_error(df_views.loc[:,i],df_views.loc[:,i])+1)/(mean_squared_error(df_views.loc[:,i],df_pred.loc[:,i])+1)))

                differences= pd.Series(ratio_mse,index=common.tolist(),name='Ratio')
                differences = differences.rename(index={'Israel': 'Israel-Palestine'})

                norm = plt.Normalize(-2, 2)
                differences = differences.sort_values(ascending=True)
                colors = plt.cm.coolwarm(norm(differences.values))
                plt.figure(figsize=(12, 14))
                sns.barplot(x=differences.values, y=differences.index, palette=colors)
                plt.xlabel('Log Ratio of MSE (illustrative)', fontsize=20)
                plt.xticks(fontsize=18)
                plt.yticks(fontsize=18)
                plt.gca().xaxis.set_major_formatter(ScalarFormatter())
                plt.gca().xaxis.get_major_formatter().set_scientific(False)
                plt.gca().spines['top'].set_visible(False)
                plt.gca().spines['right'].set_visible(False)
                plt.tight_layout()
                plt.axvline(0,color='black')
                plt.grid(axis='y',alpha=0.5)
                plt.xlim(-4,4)
                savefig_stem('Views', exts=(".png",))
            else:
                print('Skipping VIEWS plot: no overlapping columns with our predictions')
        else:
            print('Skipping VIEWS plot: empty API response')
    except Exception as e:
        print('Skipping VIEWS benchmark (API) due to network or other error:', e)



# Export summary tables for LaTeX (metrics and top errors)
try:
    metrics_tex = os.path.join(TABLE_DIR, 'metrics.tex')
    with open(metrics_tex, 'w') as f:
        f.write('% Auto-generated by report.py\n')
        if len(df_true) > 0:
            f.write('\\begin{tabular}{l r}\\hline\n')
            f.write(f'Accuracy & {accuracy:.2f} \\ \\n')
            f.write(f'Precision (weighted) & {precision:.2f} \\ \\n')
            f.write(f'Recall (weighted) & {recall:.2f} \\ \\n')
            f.write(f'F1 (weighted) & {f1:.2f} \\ \\n')
            f.write('\\hline\\end{tabular}\n')
        else:
            f.write('Preliminary report: insufficient observed data for summary metrics.\\\n')

    top_tex = os.path.join(TABLE_DIR, 'top_errors.tex')
    with open(top_tex, 'w') as f:
        f.write('% Auto-generated by report.py\n')
        if len(df_true) > 0:
            abs_err = (true_sums - pred_sums).abs().sort_values(ascending=False)
            abs_err = abs_err.rename(index={'Israel': 'Israel-Palestine'})
            topN = 10
            def _tex_clean(s):
                if not isinstance(s, str):
                    s = str(s)
                s = unicodedata.normalize('NFKD', s).encode('ascii', 'ignore').decode('ascii')
                s = (s.replace('\\', r'\textbackslash{}')
                       .replace('&', r'\&')
                       .replace('%', r'\%')
                       .replace('_', r'\_')
                       .replace('#', r'\#')
                       .replace('{', r'\{')
                       .replace('}', r'\}')
                       .replace('~', r'\textasciitilde{}')
                       .replace('^', r'\textasciicircum{}'))
                return s
            f.write('\\begin{tabular}{l r r r}\\hline\n')
            f.write('Country & True & Pred & |Diff| \\ \\n')
            f.write('\\hline\n')
            for nm in abs_err.index[:topN]:
                tr = float(true_sums.get(nm, np.nan))
                pr = float(pred_sums.get(nm, np.nan))
                dfv = float(abs_err.get(nm, np.nan))
                f.write(f'{_tex_clean(nm)} & {tr:.0f} & {pr:.0f} & {dfv:.0f} \\ \\n')
            f.write('\\hline\\end{tabular}\n')
        else:
            f.write('Preliminary report: no observed data for error ranking.\\\n')
except Exception as e:
    print('Skipping LaTeX tables export:', e)

# If no truth is available, ensure Fore_map and Heatmap exist as placeholders
if len(df_true) == 0:
    try:
        # Placeholder percentage error map
        plt.figure(figsize=(6, 4))
        plt.text(0.5, 0.5, 'Preliminary report\nNo observed data yet for error map', ha='center', va='center', fontsize=16)
        plt.axis('off')
        plt.savefig(os.path.join(OUTPUT_DIR, 'Fore_map.png'), bbox_inches='tight', dpi=150)
        plt.close()
    except Exception:
        pass
    try:
        plt.figure(figsize=(6, 4))
        plt.text(0.5, 0.5, 'Preliminary report\nNo observed data yet for confusion matrix', ha='center', va='center', fontsize=16)
        plt.axis('off')
        plt.savefig(os.path.join(OUTPUT_DIR, 'Heatmap.png'), bbox_inches='tight', dpi=150)
        plt.close()
    except Exception:
        pass
